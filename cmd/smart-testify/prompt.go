package main

import (
	"fmt"
	"github.com/spf13/cobra"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
)

var promptCmd = &cobra.Command{
	Use:   "prompt",
	Short: "Edit or view the default prompt when calling AI model to generate test cases",
}

var promptEditCMD = &cobra.Command{
	Use:   "edit",
	Short: "Edit the default prompt for the generated test cases",
	Run: func(cmd *cobra.Command, args []string) {
		// Open the config file in an editor for editing
		openEditor()
	},
}

var promptResetCMD = &cobra.Command{
	Use:   "reset",
	Short: "Reset the prompt to its original state",
	Run: func(cmd *cobra.Command, args []string) {
		// Reset the prompt to the default state
		resetPrompt()
	},
}

// create a show command to display the prompt
var promptShowCMD = &cobra.Command{
	Use:   "show",
	Short: "Show the current prompt",
	Run: func(cmd *cobra.Command, args []string) {
		// Read the prompt from the file
		prompt, err := loadPrompt()
		if err != nil {
			log.Error(fmt.Sprintf("Failed to load prompt: %v", err))
			return
		}
		fmt.Printf(string(prompt))
	},
}

func getPromptPath() string {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		log.Fatal(fmt.Sprintf("Error getting user home directory: %v", err))
	}
	return filepath.Join(homeDir, ".smart-testify", "prompt")
}

const defaultPrompt = `The output must meet below conditions. 
1. Should include success and failure cases, and include edge cases. When DB operation is involved, you should include db error. Make your best to cover 100 percent of the code. 
2. When it involve gorm DB operations, you should start sqlite in memory to mock it. For example gorm.Open(sqlite.Open(":memory:"), &gorm.Config{
		NamingStrategy: schema.NamingStrategy{SingularTable: true},
	})
3. When function has receiver, you should include it in the test name. For example, TestLuContentRatingDao_GetALL for function GetALL in LuContentRatingDao.
4. For each function you generated, you should include a comment to declare this function is generated by AI.
5. When it involves DB error case, you can simulate DB error by closing the DB connection. For example, sqlDB, _ := db.DB() sqlDB.Close(). In addition, you should put this case in the last to avoid affecting other cases.
6. When it involves time.Time, you should create it by fakeTime = time.Date(2021, 1, 1, 0, 0, 0, 0, time.UTC)
7. Be attention to the case-sensitivity of the code.
8. When DB AutoMigrate failed, you should to report the error.
9. You should generate different cases in format like t.Run("test name", func(t *testing.T) { ... }) for each case.
10. You should use github.com/stretchr/testify/assert to do the assertion. For example, assert.Equal(t, expected, actual).
11. When you need to mock functions, For example, validateOnCreateLuNF, you can use github.com/agiledragon/gomonkey/v2 to mock it. For example,
				patches := gomonkey.NewPatches()
				patches.ApplyFuncReturn(validateOnCreateLuNF, nil)
				defer patches.Reset()
`

func openEditor() {
	// Check if file exists, create it if it doesn't
	if _, err := os.Stat(getPromptPath()); os.IsNotExist(err) {
		log.Infof("Prompt file doesn't exist, creating a new one in %s.", getPromptPath())
		if err := createDefaultPrompt(); err != nil {
			return
		}
	}

	// Try to open the file using the system's default "open" tool
	var cmd *exec.Cmd
	switch runtime.GOOS {
	case "darwin": // macOS
		cmd = exec.Command("open", getPromptPath())
	case "windows": // Windows
		cmd = exec.Command("start", getPromptPath())
	default: // Linux and others
		cmd = exec.Command("xdg-open", getPromptPath())
	}

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		log.Error(fmt.Sprintf("Failed to open file with default tool: %v", err))
	}
}

func createDefaultPrompt() error {
	// create the directory if it doesn't exist
	dir := filepath.Dir(getPromptPath())
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	if err := ioutil.WriteFile(getPromptPath(), []byte(defaultPrompt), 0644); err != nil {
		return err
	}
	return nil
}

func loadPrompt() (string, error) {
	promptFilePath := getPromptPath()

	// if file not exist, create a new one
	if _, err := os.Stat(promptFilePath); os.IsNotExist(err) {
		if err := createDefaultPrompt(); err != nil {
			return "", err
		}
		return "", nil
	}

	prompt, err := ioutil.ReadFile(promptFilePath)
	if err != nil {
		return "", fmt.Errorf("error reading prompt file: %v", err)
	}
	return string(prompt), nil
}

func resetPrompt() {
	if err := createDefaultPrompt(); err != nil {
		log.Error(fmt.Sprintf("Failed to reset prompt: %v", err))
	}
}

func init() {
	promptCmd.AddCommand(promptShowCMD)
	promptCmd.AddCommand(promptEditCMD)
	promptCmd.AddCommand(promptResetCMD)
}
